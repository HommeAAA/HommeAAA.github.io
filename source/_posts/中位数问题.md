---
title: 中位数问题
date: 2020-05-21 22:15:14
tags:
  - 二分法
  - 中位数
category:
  - 算法
  - LeetCode
---
# 1. 寻找有序数组中位数
## 1. 寻找两个正序数组的中位数
[4. Median of Two Sorted Arrays](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)
给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。
请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
你可以假设 nums1 和 nums2 不会同时为空。

### 题解
1. 定义`halfLen = (m + n + 1) / 2`则
   1. 偶数个元素中位数为`(nums[halfLen] + nums[halfLen - 1]) / 2`;
   2. 奇数个元素中位数为`nums[halfLen]`;
2. 本题使用二分法寻找这样的中位线使得中位线左右个数相等或者左边比右边多1；
   ![82f47d2c1f0106c7590c51d85fc4973b.png](https://z4a.net/images/2020/05/24/82f47d2c1f0106c7590c51d85fc4973b.png)
3. 图中第一行为`nums1`, 第二行为`nums2`, 改中位线要满足`nums1[i - 1] < nums2[j]`, `nums1[i] > nums2[j - 1]`,即线左边要比线右边小；
4. `nums1[i - 1] > nums2[j]`则证明中位线的左边画多了，`right = i - 1`;
5. `nums1[i] < nums2[j - 1]`则证明中位线的右边画少了，`left = i + 1`;
6. 否则中位线划分的正好，这时候就计算线左边的最大值和右边的最小值，根据数据个数的奇偶性计算相应的中位数。

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length, n = nums2.length;
        if (m > n) {
            return findMedianSortedArrays(nums2, nums1);
        }

        int left = 0, right = m;
        //中位值的左边的数量
        int totalHalf = (m + n + 1) / 2;
        while (left <= right) {
            int i = (left + right) >>> 1;
            int j = totalHalf - i;
            //寻找分线
            if (i > 0 && nums1[i - 1] > nums2[j]) {
                right = i - 1;
            } else if (i < m && nums1[i] < nums2[j - 1]) {
                left = i + 1;
            } else {
                //找到分线左边和右边各自最大最小值
                int maxLeft = 0;
                if (i == 0) {
                    maxLeft = nums2[j - 1];
                } else if (j == 0) {
                    maxLeft = nums1[i - 1];
                } else {
                    maxLeft = Math.max(nums1[i - 1], nums2[j - 1]);
                }
                if (((m + n) & 1) == 1) {
                    return (double)maxLeft;
                }

                int maxRight = 0;
                if (i == m) {
                    maxRight = nums2[j];
                } else if (j == n) {
                    maxRight = nums1[i];
                } else {
                    maxRight = Math.min(nums1[i], nums2[j]);
                }
                return (double)(maxLeft + maxRight) / 2.0;
            }
        }
        return 0.0;
    }
}
```