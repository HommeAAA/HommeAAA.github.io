---
title: 二分系列经典问题
date: 2020-05-15 21:23:15
tags:
- 二分法
category:
- 算法
- LeetCode
- 二分法
---
# 1. 旋转数组问题
## 1. 旋转数组最小值
1. `nums[mid]`和`nums[right]`比较
2. `<`证明后半部分有序，则最小值在前半部分，`right = mid`;
3. `>`证明前半部分有序，则最小值在后半部分，`left = mid + 1`;
4. 若数组可重复，即`==`，则`right--`;

### [LeetCode 153](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/find-minimum-in-rotated-sorted-array-er-fen-fa-by-/)

假设按照升序排序的数组在预先未知的某个点上进行了旋转。 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。
请找出其中最小的元素。你可以假设数组中**不存在重复**元素。

#### 题解
``` java
class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int mid = (left + right) >>> 1;
            if (nums[mid] > nums[right]) {
                left = mid + 1;
            } else if (nums[mid] < nums[right]) {
                right = mid;
            }
        }
        return nums[left];
    }
}
```
### [LeetCode 154](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/154-find-minimum-in-rotated-sorted-array-ii-by-jyd/)
假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。
请找出其中最小的元素。注意数组中**可能存在重复**的元素。

#### 题解
``` java
class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;
        //跳出循环条件为left == right
        while (left < right) {
            int mid = (left + right) >>> 1;
            if (nums[mid] > nums[right]) {
                left = mid + 1;
            } else if (nums[mid] < nums[right]) {
                right = mid;
            } else {
                right--;            //对比153题多了这一步判断
            }
        }
        return nums[left];
    }
}
```

## 2. 旋转数组target
1. `nums[left] <= nums[mid]`，则前半部分有序，`nums[left] <= target < nums[mid]`时`right = mid - 1`，否则`left = mid + 1`;
2. 否则，后半部有序，`nums[mid] < target <= nums[right]`时`left = mid + 1`，否则`right = mid - 1`;
3. 若数组可重复，判断`nums[left] == nums[mid]`时`left++`;

### [LeetCode 33](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/ji-bai-liao-9983de-javayong-hu-by-reedfan/)
假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2]。
搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中**不存在重复的元素。**

#### 题解
``` java
class Solution {
        public int search(int[] nums, int target) {
            int left = 0, right = nums.length - 1;
            while (left <= right) {
                int mid = (left + right) >>> 1;
                if (nums[mid] == target) {
                    return mid;
                }
                //前半部分有序，注意此处用小于等于，为了匹配最后只剩两个数;
                if (nums[left] <= nums[mid]) {
                    //target可能比num[left]还小，跑右边去了所以要加限定，限定在左边
                    if (nums[left] <= target && target < nums[mid]) {
                        right = mid - 1;
                    } else {
                        left = mid + 1;
                    }
                } else if (nums[mid] < nums[right]) {
                    //同理将其限定在右边
                    if (nums[mid] < target && target <= nums[right]) {
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }
            }
            return -1;
        }
    }
```
### [LeetCode 81](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/solution/zai-javazhong-ji-bai-liao-100de-yong-hu-by-reedfan/)
假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2]。
编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。

#### 题解
```java
class Solution {
    public boolean search(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = (left + right) >>> 1;
            if (target == nums[mid]) {
                return true;
            }
            //主要是判断左边有序还是右边有序，所以直接++排除干扰项
            if (nums[left] == nums[mid]) {
                left++;
                continue;
            }
            
            if (nums[left] <= nums[mid]) {
                if (nums[left] <= target && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        return false;
    }
}
```

# 2. 可重复排序数组
## 1. 可重复排序数组元素位置/第一次出现/插入位置
1. `right = mid`找到元素最左索引，然后遍历；

### [LeetCode 34](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/)

#### 题解
找到左边界再遍历；
```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return new int[]{-1, -1};
        }
        int left = 0, right = nums.length;
        while (left < right) {
            int mid = (left + right) >>> 1;
            if (target == nums[mid]) {
                right = mid;
            } else if (target < nums[mid]) {
                right = mid;
            } else if (target > nums[mid]) {
                left = mid + 1;
            }
        }
        if (left == nums.length || nums[left] != target) {
            return new int[]{-1, -1};
        }
        int i = left;
        while (i < nums.length) {
            //注意越界;
            if (nums[i] == target) {
                i++;
            } else {
                break;
            }
        }
        return new int[]{left, i - 1};
    }
}
```

# 3. 有序矩阵找target
## 1. 各行各列递增矩阵

1. 从左下角向上遍历，target大`right++`，target小`up--`;

### [Leetcode 240](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)
编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：
* 每行的元素从左到右升序排列。
* 每列的元素从上到下升序排列。

#### 题解
左下角或者右上角开始判断：
``` java
public class Solution {
    public boolean Find(int target, int[][] array) {
        //防止array[0]越界
        if (array.length == 0 || array[0].length == 0) {
            return false;
        }
        int up = array.length - 1, right = 0;
        int len = array[0].length - 1;
        while (up >= 0 && right <= len) {
            int temp = array[up][right];
            if (temp == target) {
                return true;
            } else if (target < temp) {
                up = up - 1;
            } else if (target > temp) {
                right = right + 1;
            }
        }
        return false;
    }
}
```
## 2. 所有数严格递增

1. 展开成一维，中间元素位置`matrix[mid / n][mid % n]`;

### [Leetcode 74](https://leetcode-cn.com/problems/search-a-2d-matrix/)
编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
* 每行中的整数从左到右按升序排列。
* 每行的第一个整数大于前一行的最后一个整数。

#### 题解
当做长度为m * n的数组，row = idx / n, col = idx % n;
* 初始化左右序号
left = 0 和 right = m x n - 1。
* While left < right :
    * 选取虚数组最中间的序号作为中间序号: pivot_idx = (left + right) / 2。
    * 该序号对应于原矩阵中的 row = pivot_idx // n行 col = pivot_idx % n 列, 由此可以拿到中间元素pivot_element。该元素将虚数组分为两部分。
    * 比较 pivot_element 与 target 以确定在哪一部分进行进一步查找。
``` java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        if (m == 0) return false;
        int n = matrix[0].length;
        // 二分查找
        int left = 0, right = m * n - 1;
        int pivotIdx, pivotElement;
        while (left <= right) {
            pivotIdx = (left + right) / 2;
            pivotElement = matrix[pivotIdx / n][pivotIdx % n];
            if (target == pivotElement) return true;
            else {
                if (target < pivotElement) right = pivotIdx - 1;
                else left = pivotIdx + 1;
            }
        }
        return false;
    }
}
```

# 4. 山峰问题
## 1. 寻找任意一个峰值
1. 若`nums[mid] < nums[mid + 1]`证明峰值还在右边所以`left = mid + 1`;
2. 若`nums[mid] > nums[mid + 1]`证明峰值还在左边所以`right = mid`;

### [LeetCode 162](https://leetcode-cn.com/problems/find-peak-element/solution/xun-zhao-feng-zhi-by-leetcode/)
峰值元素是指其值大于左右相邻值的元素。

给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。

数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。

#### 题解
```java
class Solution {
    public int findPeakElement(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int mid = (left + right) >>> 1;
            if (nums[mid] > nums[mid + 1]) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
}
```

# 5. 技巧型二分
## 1. 求平方根
[69. Sqrt(x)](https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/)
实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

### 题解一
1. target在左侧时`right = mid - 1`，否则`left = mid`;
2. 所以mid必须取右中值，防止剩两个元素时死循环;
```java
class Solution {
    public int mySqrt(int x) {
        long start = 0, end = Integer.MAX_VALUE;
        //最后用到start, 所以保证跳出循环时left=right;
        while (start < end) {
            //必须取右中位数，否则start=mid一直死循环;
            long mid = (start + end + 1) >>> 1;
            if (mid * mid > x) {
                end = mid - 1;
            } else {
                start = mid;
            }
        }
        return (int) start;
    }
}
```

## 2. [寻找重复数](/判圈问题#link)