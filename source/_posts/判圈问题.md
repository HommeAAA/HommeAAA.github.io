---
title: 判圈问题
tags:
  - 快慢指针
  - Floyd判圈法
  - 二分法
category:
  - 算法
  - LeetCode
date: 2020-05-26 14:24:53
---
# 1. 寻找数组中仅有的重复数
## 1. 寻找重复数
[287. Find the Duplicate Number](https://leetcode-cn.com/problems/find-the-duplicate-number/)
给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知**至少存在一个重复**的整数。假设只有一个重复的整数，找出这个重复的数。

说明：
> **不能更改原数组**（假设数组是只读的）。
  只能使用额外的 O(1) 的空间。
  时间复杂度小于 O(n2) 。
  数组中只有一个重复的数字，但它可能不止重复出现一次。

### 题解一
1. 题目要求数组不可变，所以区别于剑指offer那题的原地swap题解
2. 采用Floyd判圈法，简单证明如下：
* 假设环长为L，从起点到环的入口的步数是a，从环的入口继续走b步到达相遇位置，从相遇位置继续走c步回到环的入口，则有`b+c=L`，其中L、a、b、c都是正整数；
* 根据上述定义，慢指针走了`a+b`步，快指针走了`2(a+b)`步。从另一个角度考虑，在相遇位置，快指针比慢指针多走了若干圈，因此快指针走的步数还可以表示成`a+b+kL`，其中k表示快指针在环上走的圈数。联立等式，可以得到`2(a+b)=a+b+kL`;
* 解得 a=kL-ba=kL−b，整理可得`a=(k−1)L+(L−b)=(k−1)L+c`
* 从上述等式可知，如果慢指针从起点出发，快指针从相遇位置出发，每次两个指针都移动一步，则慢指针走了a步之后到达环的入口，快指针在环里走了k-1圈之后又走了c步，由于从相遇位置继续走c步即可回到环的入口，因此快指针也到达环的入口。两个指针在环的入口相遇，相遇点就是答案。
```java
class Solution {
    public int findDuplicate(int[] nums) {
        int slow = 0, fast = 0;
        //区别于环形链表，没有尾部的概念
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);
        //第二阶段
        slow = 0;
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
}
```
**时间O(n), 空间O(1)**

<a name="link"/>

### 题解二
二分法+鸽巢原理
```java
class Solution {
    public int findDuplicate(int[] nums) {
        int left = 1, right = nums.length - 1;
        while (left < right) {
            int mid = (left + right) >>> 1;
            int count = 0;
            //统计小于等于n / 2的数量
            for (int num : nums) {
                if (num <= mid) {
                    count++;
                }
            }
            //数量比n / 2的值多，则重复数一定在左边
            //抽屉原理
            if (count > mid) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        //题目规定一定有个重复数，所以只剩一个数就是题解
        return left;
    }
}
```
**时间O(nlogn), 空间O(1)**

# 2. 环形链表
## 1. 环形链表II
[环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)
给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

说明：不允许修改给定的链表。

### 题解
Floyd判环
```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) {
            return null;
        }
        ListNode slow = head;
        ListNode fast = head;
        //无环则到尾端退出
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            //第二阶段
            if (slow == fast) {
                ListNode slow1 = head;
                while (slow != slow1) {
                    slow = slow.next;
                    slow1 = slow1.next;
                }
                return slow;
            }
        }
        return null;
    }
}
```