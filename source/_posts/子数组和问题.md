---
title: 子数组和问题
tags:
  - 前缀和
category:
  - 算法
  - LeetCode
  - 动态规划
date: 2020-05-28 16:30:02
---

# 1. 子数组和问题
1. 子数组和问题一般考虑使用前缀和来解
2. [i,j]的子数组和问题和`pre[j] - pre[i - 1]`相关
3. 用map统计频数，并且初始化map.put(0, 1);

## 1. 和为K的子数组
[560. Subarray Sum Equals K](https://leetcode-cn.com/problems/subarray-sum-equals-k/)
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。

### 题解
1. `pre[i] - pre[j - 1] == k` => `pre[j - 1] == pre[i] - k`
2. `pre[i]`代表当前前缀和， `pre[j - 1]`为之前的前缀和，相减就是`(j, i)`的子数组之和；
3. 因此只需要累加以`i`为结尾的前缀和为`pre[i - 1] - k`值的频数即可；
4. 而`pre[i] == pre[i - 1] + nums[i]`, 这一步可以当做状态转移方程，即当前的前缀和；

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int count = 0, pre = 0;
        Map<Integer, Integer> map = new HashMap<>();
        //初始化前缀和为0的个数为1
        map.put(0, 1);
        for (int i = 0; i < nums.length; i++) {
            //pre[i], 当前的前缀和
            pre += nums[i];
            //pre[j - 1] == pre[i] - k, 之前的前缀和
            if (map.containsKey(pre - k)) {
                count += map.get(pre - k);
            }
            //存放目前的前缀和，之后进入下一个循环就变成pre[i - 1]
            map.put(pre, map.getOrDefault(pre, 0) + 1);
        }
        return count;
    }
}
```
**时间O(n), 空间O(n)**

## 2. 和可被 K 整除的子数组
[974. Subarray Sums Divisible by K](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/)
给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。

### 题解
1. `(pre[i] - pre[j - 1]) mod k == 0` => `pre[j - 1] mod k == pre[i] mod k`
2. 即找到前缀和取余相等的值即可

```java
class Solution {
    public int subarraysDivByK(int[] A, int K) {
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        int ans = 0, sum = 0;
        for (int i : A) {
            //前缀和
            sum += i;
            //Java负数取余为负数，所以这里将其变为正数
            int modulus = (sum % K + K) % K;
            //pre[j] mod k == pre[i - 1] mod k即前缀和取余相等
            //代表i,j的子数组取余为0
            //map中缓存的是取余相等的子数组数量
            int same = map.getOrDefault(modulus, 0);
            //计数
            ans += same;
            map.put(modulus, same + 1);
        }
        return ans;
    }
}
```
**时间O(n), 空间O(min(n, k))**