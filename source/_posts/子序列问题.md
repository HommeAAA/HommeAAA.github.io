---
title: 子序列问题
tags:
  - 动态规划
category:
  - 算法
  - LeetCode
  - 动态规划
date: 2020-08-20 20:16:03
---
[TOC]
## 1. 连续子序列
#### 1. 和最大连续子序列
1. 状态转移方程`dp[i] = Math.max(array[i], dp[i - 1] + array[i]);`dp[i - 1]若为负则会使总值变小所以直接为array[i];

###### 1. [LeetCode 53](https://leetcode-cn.com/problems/maximum-subarray/) (最大子序和)
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**题解**
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int len = nums.length;
        int currNum = nums[0];
        int maxNum = nums[0];
        for (int i = 1; i < len; i++) {
            currNum = Math.max(currNum + nums[i], nums[i]);
            maxNum = Math.max(maxNum, currNum);
        }
        return maxNum;
    }
}
```
#### 2. 乘积最大连续子序列
1. 维护一个dpMax, 一个dpMin, 当`nums[i] < 0的时候交换dpMax, dpMin;

###### 1. [LeetCode 152](https://leetcode-cn.com/problems/maximum-product-subarray/solution/hua-jie-suan-fa-152-cheng-ji-zui-da-zi-xu-lie-by-g/) (乘积最大子数组)
给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。

**题解**
dp方程可以理解为若当前nums[i]可乘就乘，否则丢弃从当前nums[i]开始。代表当前位置最大子串。
本题可以维护一个dpMin一旦nums[i]是负数，则最大变最小，最小变最大，即可以交换dpMax, dpMin。
```java
class Solution {
    public int maxProduct(int[] nums) {
        int len = nums.length;
        int dpMax = nums[0];
        int dpMin = nums[0];
        int maxNum = nums[0];
        for (int i = 1; i < len; i++) {
            if (nums[i] < 0) {
                int temp = dpMax;
                dpMax = dpMin;
                dpMin = temp;
            }
            dpMax = Math.max(nums[i], dpMax * nums[i]);
            dpMin = Math.min(nums[i], dpMin * nums[i]);
            maxNum = Math.max(maxNum, dpMax);
        }
        return maxNum;
    }
}
```
#### 3. 含有某个值的最短连续子序列
1. `leftMap`第一次出现的索引位置，`rightMap`最后一次出现的索引位置;
```java
//只put第一次索引;
if (!leftMap.containsKey(nums[i])) {
    leftMap.put(nums[i], i);
}
//刷新索引，即最后一次索引;
rightMap.put(nums[i], i);
```
###### 1. [LeetCode 697](https://leetcode-cn.com/problems/degree-of-an-array/solution/shu-zu-de-du-by-leetcode/) (数组的度)
给定一个非空且只包含非负数的整数数组 nums, 数组的度的定义是指数组里任一元素出现频数的最大值。

你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。
**题解**
```java
class Solution {
    public int findShortestSubArray(int[] nums) {
        HashMap<Integer, Integer> leftMap = new HashMap<>();
        HashMap<Integer, Integer> rightMap = new HashMap<>();
        HashMap<Integer, Integer> countMap = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            //只put第一次索引;
            if (!leftMap.containsKey(nums[i])) {
                leftMap.put(nums[i], i);
            }
            //刷新索引，即最后一次索引;
            rightMap.put(nums[i], i);
            countMap.put(nums[i], countMap.getOrDefault(nums[i], 0) + 1);
        }
        int maxCount = Collections.max(countMap.values());
        int minLen = Integer.MAX_VALUE;
        for (int key : countMap.keySet()) {
            if (countMap.get(key) == maxCount) {
                minLen = Math.min(minLen, rightMap.get(key) - leftMap.get(key) + 1);
            }
        }
        return minLen;
    }
}
```
#### 4. 最长01连续子序列
1. 将0当做-1，则建一个count[], 保存每次和当前nums[i]加的结果；
2. count相等的两个索引之间0, 1数量是相等的；
3. 所以map存放第一次出现的count值的索引，类似上题；
4. 没出现一次map中有的count, 就比较当前索引和map里的索引的差值，最终保存最大的即为结果；

###### 1. [LeetCode 525](https://leetcode-cn.com/problems/contiguous-array/solution/lian-xu-shu-zu-by-leetcode/) (连续数组)
给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。

**题解**
用HashMap记录第一个count的index；(count : index)；count相等代表第一次出现该count的索引到此索引之间的0, 1个数相等；
```java
class Solution {
    public int findMaxLength(int[] nums) {
        HashMap<Integer, Integer> map = new HashMap<>();
        map.put(0, -1);         //防止整个数组为子串的特例;
        int length = nums.length;
        int maxLen = 0, count = 0;
        for (int i = 0; i < length; i++) {
            count += (nums[i] == 1) ? 1 : -1;
            if (map.containsKey(count)) {
                maxLen = Math.max(maxLen, i - map.get(count));
            } else {
                map.put(count, i);
            }
        }
        return maxLen;
    }
}
```

## 2. 子序列（非连续）
#### 1. 最长递增子序列
1. 动态规划，双循环，第二层循环如果`nums[i] > nums[j]`就遍历寻找[0, i) 之间最大的子序列并加上1;
2. 否则不能加上nums[i], 即dp[j]的最大值就是dp[i]的值;
   
1. 二分dp优化O(nlogn), 维护一个tail[]数组，当做每轮给这个最长序列增加的值，二分也是为了后序如果有更小的值就实时替换维护一个每个位置都最小的情况；
2. 遍历nums时每次二分寻找到可以替换的值即比该数大的，如果没有则末尾追加一个，同时res++; 利用`right = mid`向左逼近;

###### 1. [LeetCode 300](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/) (最长上升子序列)

**题解一**
动态规划，双循环，第二层循环如果nums[i]大于nums[j]就遍历寻找[0, i) 之间最大的子序列并加上1
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        int res = 1;
        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

**题解二**
二分dp优化O(nlogn), 维护一个tail[]数组，遍历nums时每次二分寻找到可以替换的值即比该数大的，如果没有则末尾追加一个，同时res++; 利用`right = mid`向左逼近;
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int res = 0;
        int[] tail = new int[nums.length];
        for (int num : nums) {
            int i = 0, j = res;
            while (i < j) {
                int mid = (i + j) >>> 1;
                if (num > tail[mid]) {
                    i = mid + 1;
                } else {
                    j = mid;
                }
            }
            //i == j;
            tail[i] = num;
            //判断是否插在了末尾;
            if (j == res) {
                res++;
            }
        }
        return res;
    }
}
```
###### 2. [LeetCode 354](https://leetcode-cn.com/problems/russian-doll-envelopes/solution/e-luo-si-tao-wa-xin-feng-wen-ti-by-leetcode/)（俄罗斯套娃）
给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

> 说明:
不允许旋转信封。

**题解**
先按w升序排序，即可转化为h的最长子序列题，但w可能相等，这种情况就按h的降序排序，即筛掉w相等的情况;
```java
class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        if (envelopes.length == 0 || envelopes[0].length == 0) {
            return 0;
        }
        //排序;
        Arrays.sort(envelopes, (int[] arr1, int[] arr2) -> {
            if (arr1[0] == arr2[0]) {
                return arr2[1] - arr1[1];
            } else {
                return arr1[0] - arr2[0];
            }
        });
        int[] sec = new int[envelopes.length];
        //遍历赋值所有的h;
        for (int i = 0; i < envelopes.length; i++) {
            sec[i] = envelopes[i][1];
        }
        return lis(sec);
    }
    private int lis(int[] sec) {
        int[] tail = new int[sec.length];
        int res = 0;
        for (int num : sec) {
            int left = 0, right = res;
            while (left < right) {
                int mid = (left + right) >>> 1;
                if (tail[mid] < num) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            tail[left] = num;
            if (left == res) {
                res++;
            }
        }
        return res;
    }
}
```

#### 2. 最长回文子序列
1. 二维动态规划，`dp[0][s.length() - 1]`代表该区间字符串的最长回文子序列；
2. 先初始化`dp[i][i]`为1, 因为每个字母都是回文串；
3. 从后往前遍历，`j = i + 1`
   1. 若`s.charAt(i) == s.charAt(j)`则转移方程为`dp[i][j] = dp[i + 1][j - 1] + 2`
   2. 否则为`max(dp[i + 1][j], dp[i][j - 1])`

###### 1. [LeetCode 516](https://leetcode-cn.com/problems/longest-palindromic-subsequence/) (最长回文子序列)
给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000

**题解**
```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int[][] dp = new int[s.length()][s.length()];
        for (int i = 0; i < s.length(); i++) {
            dp[i][i] = 1;
        }
        for (int i = s.length() - 1; i >= 0; i--) {
            for (int j = i + 1; j < s.length(); j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][s.length() - 1];
    }
}
```

###### 2. [LeetCode 1312](https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/) (让字符串成为回文串的最少插入次数)
给你一个字符串s, 每一次操作你都可以在字符串的任意位置插入任意字符

请你返回让s成为回文串的**最少操作次数**

**题解**

本题就是用字符串长度减去最长回文子序列的长度，即求的是最长不回文字串
```java
class Solution {
    public int minInsertions(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        int[][] dp = new int[s.length()][s.length()];
        for (int i = 0; i < s.length(); i++) {
            dp[i][i] = 1;
        }
        for (int i = s.length() - 1; i >= 0; i--) {
            for (int j = i + 1; j < s.length(); j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return s.length() - dp[0][s.length() - 1];
    }
}
```