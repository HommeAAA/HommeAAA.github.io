---
title: 二叉树结构判断问题
tags:
  - 二叉树
  - 递归
category:
  - 算法
  - LeetCode
  - 二叉树
date: 2020-06-01 15:11:03
---
# 1. 判断二叉树是否相同或者对称
## 1. 对称二叉树
[101. Symmetric Tree](https://leetcode-cn.com/problems/symmetric-tree/)
给定一个二叉树，检查它是否是镜像对称的。

### 题解一
1. 递归判断左子树是否等于右子树
2. `check()`方法是[100. Same Tree](https://leetcode-cn.com/problems/same-tree/)代码

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return check(root, root);
    }

    private boolean check(TreeNode root1, TreeNode root2) {
        if (root1 == null && root2 == null) {
            return true;
        }
        //过滤了全null
        if (root1 == null || root2 == null) {
            return false;
        }
        return root1.val == root2.val && check(root1.left, root2.right) && check(root1.right, root2.left);
    }
}
```
**时间O(n), 空间O(n)**

### 题解二
1. 用迭代的方法，新建一个队列
2. 每次加入两个值，若发现不对称直接返回false, 否则按照左右，右左加入队列中。

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        queue.add(root);
        while (!queue.isEmpty()){
            TreeNode node1 = queue.poll();
            TreeNode node2 = queue.poll();
            //判断
            if(node1 == null && node2 == null){
                continue;
            }
            if(node1 == null || node2 == null){
                return false;
            }
            if(node1.val != node2.val){
                return false;
            }
            //左右右左
            queue.add(node1.left);
            queue.add(node2.right);
            queue.add(node1.right);
            queue.add(node2.left);
        }
        return true;
    }
}
```
**时间O(n), 空间O(n)**

# 2. 判断二叉树的子树以及子结构
## 1. 另一个树的子树
[572. Subtree of Another Tree](https://leetcode-cn.com/problems/subtree-of-another-tree/)
给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。

### 题解
1. 本题是求子树，区别于子结构，子树需要一直追溯到叶子节点

```java
//子树不同于子结构
class Solution {
    public boolean isSubtree(TreeNode s, TreeNode t) {
        if (t == null) {
            return true;
        }
        //能走到这一步证明t != null而s == null则错误
        if (s == null) {
            return false;
        }
        return isSameTree(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);
    }
    
    public boolean isSameTree(TreeNode s, TreeNode t) {
        if (s == null && t == null) {
            return true;
        }
        //过滤都为null情况
        if (s == null || t == null) {
            return false;
        }
        if (s.val != t.val) {
            return false;
        }
        //当前节点一致的情况
        return isSameTree(s.left, t.left) && isSameTree(s.right, t.right);
    }
}
```