---
title: 路径系列问题
tags:
  - 动态规划
category:
  - 算法
  - LeetCode
  - 动态规划
date: 2020-05-31 18:45:34
---
1. 这种类型的题首先是要初始化dp的初始值，即第一行第一列的值；
2. 新开`dp[]`则代表有几种路径；
3. 或者以原数组为`dp[]`代表当前为是否会对后续有影响，没有则赋值0；
4. 前一种状态为左 + 上，即`dp[i - 1][j] + dp[i][j - 1]`。

# 1. 左上到右下的路径问题
## 1. 不同路径I
[62. Unique Paths](https://leetcode-cn.com/problems/unique-paths/)
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
问总共有多少条不同的路径？

### 题解
```java
class Solution {
    public int uniquePaths(int m, int n) {
        if (m == 0 || n == 0) {
            return 0;
        }
        int[][] dp = new int[m][n];
        //动态规划一定要考虑清楚初始条件
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int i = 0; i < n; i++) {
            dp[0][i] = 1;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
```
**时间O(m * n), 空间O(m * n)**

## 2. 不同路径II
[63. Unique Paths II](https://leetcode-cn.com/problems/unique-paths-ii/)
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

### 题解
1. 该题利用原数组作为动态规划数组；
2. 初始化第一行第一列的时候，遇到障碍之前都为1，遇到了障碍将其设为0，以及后续都为0代表无路可走；
3. 没有障碍物的时候，状态为`obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]`；
4. 否则设为0，代表此路不通，即该点对后续路径无贡献。

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        if (obstacleGrid[0][0] == 1) {
            return 0;
        }
        obstacleGrid[0][0] = 1;
        //是否有贡献，第一行第一列若有只有一条路径选择
        for (int i = 1; i < m; i++) {
            obstacleGrid[i][0] = (obstacleGrid[i][0] == 0 && obstacleGrid[i - 1][0] == 1) ? 1 : 0; 
        }
        for (int i = 1; i < n; i++) {
            obstacleGrid[0][i] = (obstacleGrid[0][i] == 0 && obstacleGrid[0][i - 1] == 1) ? 1 : 0; 
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 0) {
                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
                } else {
                    obstacleGrid[i][j] = 0;
                }
            }
        }
        return obstacleGrid[m - 1][n - 1];
    }
}
```

## 3. 最小路径和
[64. Minimum Path Sum](https://leetcode-cn.com/problems/minimum-path-sum/)
给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步。

### 题解
1. 该题也是利用原数组做dp数组；
2. 初始化第一行第一列；
3. 该点必定是从左或者上来所以娶妻最小值相加。

```java
class Solution {
    public int minPathSum(int[][] grid) {
        if (grid == null || grid[0].length == 0) {
            return 0;
        }
        int m = grid.length, n = grid[0].length;
        //初始值
        for (int i = 1; i < m; i++) {
            grid[i][0] += grid[i - 1][0];
        }
        for (int i = 1; i < n; i++) {
            grid[0][i] += grid[0][i - 1];
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
            }
        }
        return grid[m - 1][n - 1];
    }
}
```

# 2. 三角形路径问题
## 1. 三角形最小路径和
[120. Triangle](https://leetcode-cn.com/problems/triangle/)
给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。
相邻的结点在这里指的是下标与上一层结点下标相同或者等于上一层结点下标 + 1 的两个结点。
**空间为O(n)**

### 题解
1. 先初始化最后一层，然后由于当前的状态只和下面一层的`j, j + 1`相关，所以只需要一维数组；
2. 利用`triangle.get(i).get(j)`获取当前行的`j`值与下一行的`j, j + 1`较小的相加。

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int m = triangle.size();
        List<Integer> list = triangle.get(m - 1);
        int[] dp = new int[m];
        //自底向上，初始化最后一层
        for (int i = 0; i < list.size(); i++) {
            dp[i] = list.get(i);
        }
        for (int i = m - 2; i >= 0; i--) {
            for (int j = 0; j < triangle.get(i).size(); j++) {
                dp[j] = Math.min(dp[j], dp[j + 1]) + triangle.get(i).get(j);
            }
        }
        return dp[0];
    }
}
```